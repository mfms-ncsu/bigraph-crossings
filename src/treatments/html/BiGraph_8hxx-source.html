<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SBG Software (treatments): BiGraph.hxx Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>BiGraph.hxx</h1><a href="BiGraph_8hxx.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 
00003 
00004 
00005 
00006 <span class="comment">//     Copyright (C) 2001,2007  Matthias Stallmann.</span>
00007 <span class="comment">//     Contact: matt_stallmann@ncsu.edu</span>
00008 <span class="comment">//</span>
00009 <span class="comment">//     This program is free software; you can redistribute it and/or modify</span>
00010 <span class="comment">//     it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment">//     the Free Software Foundation; either version 2 of the License, or</span>
00012 <span class="comment">//     (at your option) any later version.</span>
00013 <span class="comment">//</span>
00014 <span class="comment">//     This program is distributed in the hope that it will be useful,</span>
00015 <span class="comment">//     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment">//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment">//     GNU General Public License for more details.</span>
00018 <span class="comment">//</span>
00019 <span class="comment">//     You should have received a copy of the GNU General Public License along</span>
00020 <span class="comment">//     with this program (file COPYING.txt); if not, write to the Free Software</span>
00021 <span class="comment">//     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301</span>
00022 <span class="comment">//     USA.</span>
00023 
00024 <span class="comment">//  2 Jan 1999 - changes to accomodate reading ordering from a separate file</span>
00025 
00026 <span class="comment">// 27 Jan 1999 - changed best_insertion so that it reports the change in</span>
00027 <span class="comment">// number of crossings; also got rid of "to_the_right" and</span>
00028 <span class="comment">// "allow_equality".</span>
00029 
00030 <span class="comment">// 14 Apr 1999 - added get_node_number() and get_name()</span>
00031 
00032 <span class="comment">// 29 Jun 1999 - got rid of permute()</span>
00033 
00034 <span class="comment">// 29 Jul 2002 - added output_dre to allow us to use the dreadnaught</span>
00035 <span class="comment">// program for testing isomorphism</span>
00036 
00037 <span class="preprocessor">#ifndef BIGRAPH_HXX</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define BIGRAPH_HXX</span>
00039 <span class="preprocessor"></span>
00040 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00041 
00042 <span class="preprocessor">#include"<a class="code" href="IntSet_8h.html">IntSet.h</a>"</span>
00043 <span class="preprocessor">#include&lt;iostream&gt;</span>
00044 
00045 <span class="keyword">struct </span>BGRecord;
00046 
00047 <span class="comment">// A bipartite graph consists of two sets of vertices V0 = {0, ..., n0-1} and</span>
00048 <span class="comment">// V1 = {0, ..., n1-1}; each vertex in V0 is connected to a subset of the</span>
00049 <span class="comment">// vertices in V1 (and vice versa)</span>
00050 
00051 <span class="keyword">class </span>BiGraph {
00052   BGRecord * my_graph;
00053 <span class="keyword">public</span>:
00054   BiGraph();
00055   <span class="comment">// POST: this is an empty bipartite graph (with some preliminary memory</span>
00056   <span class="comment">//       allocation)</span>
00057 
00058   BiGraph(<span class="keyword">const</span> BiGraph &amp;);     <span class="comment">// copy constructor</span>
00059   BiGraph &amp; operator = (<span class="keyword">const</span> BiGraph &amp;); <span class="comment">// assignment operator</span>
00060   ~BiGraph();
00061 
00062   <span class="keywordtype">void</span> read_with_order( istream &amp; dot, istream &amp; ord );
00063   <span class="comment">// POST: this graph has been extracted in "dot" format from 'dot'</span>
00064   <span class="comment">//       using the layer ordering specified in "ord" format in 'ord'</span>
00065 
00066   <span class="keywordtype">void</span> read( istream &amp; dot );
00067   <span class="comment">// alternate version when no .ord file is given</span>
00068 
00069   <span class="keywordtype">int</span> n0() <span class="keyword">const</span>;
00070   <span class="keywordtype">int</span> n1() <span class="keyword">const</span>;
00071   <span class="keywordtype">int</span> number_of_edges() <span class="keyword">const</span>;
00072 
00073   <span class="keywordtype">int</span> degree(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;
00074   <span class="comment">// PRE: 0 &lt;= i &lt; n0</span>
00075   <span class="comment">// POST: retval == degree of vertex i in V0</span>
00076 
00077   <span class="keywordtype">int</span> get_node_number( <span class="keyword">const</span> string name ) <span class="keyword">const</span>;
00078   <span class="comment">// POST: retval == current node number in V0 of node with the given name,</span>
00079   <span class="comment">//                 or -1 if no such node exists</span>
00080 
00081   <span class="keyword">const</span> string get_name( <span class="keywordtype">int</span> i ) <span class="keyword">const</span>;
00082   <span class="comment">// POST: retval == name of node i in V0</span>
00083 
00084   <span class="keywordtype">int</span> max_degree_vertex() <span class="keyword">const</span>;
00085   <span class="comment">// POST: retval == maximum degree vertex in V0</span>
00086 
00087   <span class="keywordtype">int</span> min_degree_vertex() <span class="keyword">const</span>;
00088   <span class="comment">// POST: retval == minimum degree vertex in V0</span>
00089 
00090   <span class="keywordtype">void</span> output_order( ostream&amp; out, <span class="keyword">const</span> string graph_name, 
00091                                    <span class="keyword">const</span> string treatment_name );
00092   <span class="comment">// POST: out contains the current layer ordering for this graph in ord</span>
00093   <span class="comment">//       format</span>
00094  
00095   <span class="keywordtype">void</span> output_dre( ostream&amp; out );
00096   <span class="comment">// POST: out contains the graph in .dre (dreadnaught) format, a very</span>
00097   <span class="comment">// simple format in which nodes are numbered 0 through n-1; the first</span>
00098   <span class="comment">// two lines are</span>
00099   <span class="comment">//      n=number_of_nodes $=0 g</span>
00100   <span class="comment">//      $$</span>
00101   <span class="comment">// followed by a line of the form</span>
00102   <span class="comment">//      node_number: x_1 x_2 ... x_k;</span>
00103   <span class="comment">// where x_1, x_2, ..., x_k are the number of the k neighbors of the node</span>
00104   <span class="comment">// whose number is node_number.  Edges from higher numbers to lower</span>
00105   <span class="comment">// numbers can be omitted for undirected (so the output for a bigraph</span>
00106   <span class="comment">// looks the same whether we consider it directed or undirected).  We</span>
00107   <span class="comment">// number the nodes on layer 0 from 0 to n_0 - 1, those on layer 1 from</span>
00108   <span class="comment">// n_0 to n_0 + n_1 - 1.</span>
00109 
00110   <span class="keywordtype">void</span> switch_sides();
00111   <span class="comment">// switch V0 and V1 (for the algorithms, V0 is the side that can be</span>
00112   <span class="comment">// permuted)</span>
00113 
00114   <span class="keywordtype">void</span> sort(<span class="keywordtype">int</span> * key);
00115   <span class="comment">// PRE:  key[i] is defined for each i = 0, ..., n0 - 1 </span>
00116   <span class="comment">// POST: vertices of V0 have been permuted so that the relationship</span>
00117   <span class="comment">//       between i and key[i] is maintained and </span>
00118   <span class="comment">//       key[0] &lt;= key[1] &lt;= ... &lt;= key[n0 - 1].</span>
00119   <span class="comment">//       This implies that the permutation of the key array has also been</span>
00120   <span class="comment">//       modified. </span>
00121 
00122   Iterator adjacency_list(<span class="keywordtype">int</span> i);
00123   <span class="comment">// PRE: 0 &lt;= i &lt; n0</span>
00124   <span class="comment">// POST: retval == an iterator for the adjacency list of vertex i in V0</span>
00125 
00126   BackIterator backwards_adjacency_list(<span class="keywordtype">int</span> i);
00127   <span class="comment">// PRE: 0 &lt;= i &lt; n0</span>
00128   <span class="comment">// POST: retval == a backwards iterator for the adjacency list of vertex</span>
00129   <span class="comment">//                 i in V0 </span>
00130 
00131   <span class="keywordtype">void</span> sort(<span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> * key, <span class="keywordtype">bool</span> descending = <span class="keyword">false</span>);
00132   <span class="comment">// PRE: 0 &lt;= i &lt; n0 &amp;&amp; key[j] is defined for each j in adjacency_list(i) </span>
00133   <span class="comment">// POST: the adjacency list of vertex i in V0 has been arranged so that</span>
00134   <span class="comment">//       key[x_1] &lt;= key[x_2] &lt;= ... &lt;= key[x_k], where x_1, ..., x_k is</span>
00135   <span class="comment">//       the sequence emitted by the iterator for it.</span>
00136   <span class="comment">//       If descending == true, key[x_1] &gt;= key[x_2] &gt;= ... &gt;= key[x_k].</span>
00137   
00138   <span class="keywordtype">void</span> insert(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j);
00139   <span class="comment">// PRE: 0 &lt;= i, j &lt; n0</span>
00140   <span class="comment">// POST: vertex i in V0 has been inserted after vertex j (before if j &lt; i)</span>
00141 
00142   <span class="keywordtype">void</span> swap(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j);
00143   <span class="comment">// PRE: 0 &lt;= i &lt;= j &lt; n0</span>
00144   <span class="comment">// POST: vertex i in V0 has been exchanged with vertex j</span>
00145   <span class="comment">// NOT IMPLEMENTED!</span>
00146 
00147   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> crossings() <span class="keyword">const</span>;
00148   <span class="comment">// POST: retval == current number of edge crossings</span>
00149 
00150   <span class="keywordtype">int</span> change_in_crossings(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) <span class="keyword">const</span>;
00151   <span class="comment">// PRE: 0 &lt;= i, j &lt; n0</span>
00152   <span class="comment">// POST: retval == change in # of edge crossings after the insert(i, j)</span>
00153 
00154   <span class="keywordtype">double</span> average(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;
00155   <span class="comment">// PRE: 0 &lt;= i &lt; n0</span>
00156   <span class="comment">// POST: retval == (biased) median of items in adjacency list for vertex</span>
00157   <span class="comment">//                 i in V0</span>
00158   <span class="comment">//                 (ratio is the ratio of mean to the mean/median mix,</span>
00159   <span class="comment">//                 i.e. 0.0 represents all median, 1.0 all mean)</span>
00160  
00161   <span class="keywordtype">int</span> best_insertion( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> &amp; change_in_crossings ) <span class="keyword">const</span>;
00162   <span class="comment">// PRE: 0 &lt;= i &lt; n0</span>
00163   <span class="comment">// POST: retval == the j != i for which change_in_crossings(i, j) is</span>
00164   <span class="comment">//                 minimal, or IntSet::DUMMY if no such j exists</span>
00165   <span class="comment">//                 (i.e. when there's only one node on this side) </span>
00166   <span class="comment">//       change_in_crossings == change_in_crossings(i, j) for that j</span>
00167 
00168   <span class="keywordtype">int</span> best_swap(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;
00169   <span class="comment">// PRE: 0 &lt;= i &lt; n0</span>
00170   <span class="comment">// POST: retval == the j for which swap(i, j) gives the smallest number</span>
00171   <span class="comment">//                 of crossings </span>
00172   <span class="comment">// NOT IMPLEMENTED!</span>
00173 
00174   <span class="keyword">friend</span> ostream&amp; operator &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> BiGraph&amp; bg);
00175 };
00176 
00177 <span class="preprocessor">#endif</span>
00178 <span class="preprocessor"></span>
00179 <span class="comment">// Local Variables: ***</span>
00180 <span class="comment">//  mode:c++ ***</span>
00181 <span class="comment">// End: ***</span>
00182 
00183 <span class="comment">//  [Last modified: 2007 08 08 at 18:39:37 GMT]</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Aug 8 17:10:34 2007 for SBG Software (treatments) by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
